*   Each transaction has "IsValid" boolean. In transfer functionaliy, if the process crushed in the middle,
    the "IsValid" property will be an indication.
*   "CreateBalance" increments a counter in an atomic way, utilizing "Interlocked.Increment".
*   "GetBalance" checks if the id that is provided is higher than the counter of the balance ids.
    If indeed, than throws error that the balance doesn't exist. Otherwise, returns the balance.
    The balances are stored in a thread safe dictionary. If the key doesn't exist, then create a zeroed value balance and return it.
    If it does exist, then return the balance.
    The value in the dictionary is Balance class, and it contains an ImmutableList (this data structure is thread safe) of transactions,
    and each one has "IsValid", and "Value" properties.
*   "Charge" locks the access to the value of the key in the balances dictionary, i.e. locks all access to the balance class List of transactions.
    then, it enumerates on the list of transactions and calculates the balance. If the charge is higher than the balance, throws exception.
    Else, it cleans the list and append a single item - the posotive or zeroed balance. Practically, the asymptotic behavior is Amortized, sometimes O(1) and
    sometimes O(N).
    "Charge" ignores and removes invalid transactions.
*   "Load" Adds a transaction to the balance's list of transactions without locking anything.
*   "Transfer" does different type of "Charge" and "Load", where both accept a reference to "IsValid" boolean. If it completes the transfer,
    The boolean that is referenced by the transactions of both Charge and Load, its value is changed to "true".